[
  {
    "id": 1,
    "prompt": "The user taps on grid cells, then clicks on save and numbers are stored in column 1 starting from row 8 all the way till the end.The numbers need to be evaluated based on the following conditions:\n1. Digit 4 contributes a value of 4000 in each number.\n2. Each of them is an odd number.",
    "question": "The user taps on grid cells, then clicks on save and numbers are stored in column 1 starting from row 8 all the way till the end.The numbers need to be evaluated based on the following conditions:\n1. Digit 4 contributes a value of 4000 in each number.\n2. Each of them is an odd number.",
    "code": "function getConditionCorrect(\n  variables,\n  conditions,\n  currConditionIndex,\n  getValue,\n  global_context_variables\n) {\n  /* ── 1) pull out the table & the “answer” column coordinates ───────── */\n  const tableData = global_context_variables?.tableData ?? {};\nconst answerStartCoords = global_context_variables?.answer_list_start?.split(\":\");\nconst ansRow = Number(answerStartCoords?.[0]);\nconst ansCol = Number(answerStartCoords?.[1]);\n\n  /* ── 2) walk downward and gather every saved number string ─────────── */\n  const numbers = [];           // e.g. [\"4583\", \"4765\", …]\n  let row = ansRow;\n  while (row < tableData.cells.length) {\n    const cell = tableData.cells[row]?.[ansCol];\n    const txt =\n      cell?.text?.enabled === true && cell?.text?.value?.default !== \"\"\n        ? cell.text.value.default\n        : \"\";\n    if (txt === \"\") break;      // first blank → stop\n    numbers.push(txt);\n    row += 1;\n  }\n\n  /* ── 3) helper predicates ─────────────────────────────────────────── */\n  const has4InThousands = (s) => {\n    const n = Number(s);\n    if (!Number.isFinite(n) || n < 1000) return false;       // needs ≥ 4 digits\n    return Math.floor(n / 1000) % 10 === 4;                  // thousands digit\n  };\n  const isOdd = (s) => {\n    const n = Number(s);\n    return Number.isFinite(n) && n % 2 === 1;\n  };\n\n  /* ── 4) evaluate whichever rule the caller asks for ───────────────── */\n  switch (currConditionIndex) {\n    case 0: {\n  // 0-a) every number must be 5 digits AND cannot start with 0\n  const allFiveDigits = numbers.every(\n    (s) => s.length === 5 && s[0] !== \"0\"\n  );\n  if (!allFiveDigits) return false;\n\n  // 0-b) thousands-digit must be 4 in every number\n  return numbers.every(has4InThousands);\n}\n\n    case 1:   // “Each of them are odd numbers.”\n      return numbers.every(isOdd);\n\n    default:\n      return false;  // unsupported rule index\n  }\n}\n\n\n\nfunction evaluate(params) {\n  const { tableData, global_context_variables } = params;\n\n  console.log(\"params-----\", JSON.parse(JSON.stringify(params)));\n\n  /* ── 1) derive starting coordinates from answer_list_start ──────── */\n  const answerStartCoords =\n    global_context_variables?.answer_list_start?.split(\":\") ?? [];\n  const ansRow = Number(answerStartCoords[0]) || 0;   // default → 0\n  const ansCol = Number(answerStartCoords[1]) || 0;   // default → 0\n\n  /* ── 2) collect the numbers below that starting cell ────────────── */\n  const numbers = [];\n  let row = ansRow;\n  while (row < (tableData.cells ?? []).length) {\n    const cell = tableData.cells[row]?.[ansCol];\n    const txt =\n      cell?.text?.enabled === true && cell?.text?.value?.default !== \"\"\n        ? cell.text.value.default\n        : \"\";\n    if (txt === \"\") break;          // blank cell → end of list\n    numbers.push(txt);\n    row += 1;\n  }\n\n  /* ── 3) helper predicates ───────────────────────────────────────── */\n  const thousandsDigitIs4 = (s) => {\n    const n = Number(s);\n    return Number.isFinite(n) && Math.floor(n / 1000) % 10 === 4;\n  };\n  const isOdd = (s) => {\n    const n = Number(s);\n    return Number.isFinite(n) && n % 2 === 1;\n  };\n\n  /* ── 4) evaluate the two conditions ─────────────────────────────── */\n  // Condition 0: 5-digit, not starting with 0, thousands digit = 4\n  const cond0 =\n    numbers.length > 0 &&\n    numbers.every(\n      (s) => s.length === 5 && s[0] !== \"0\" && thousandsDigitIs4(s)\n    );\n\n  // Condition 1: all numbers are odd\n  const cond1 = numbers.length > 0 && numbers.every(isOdd);\n\n  /* ── 5) return structure ────────────────────────────────────────── */\n  return {\n    is_correct: cond0 && cond1,           // overall grade\n    cell_level_is_correct: [],            // intentionally empty\n    condition_level_is_correct: [cond0, cond1],\n  };\n}\n\n",
    "metadata": {
      "activity_type": null,
      "difficulty": null,
      "tags": [],
      "source": "text-to-function(evaluation).xlsx",
      "row_index": 2
    }
  },
  {
    "id": 2,
    "prompt": "The user taps on grid cells, then clicks on save and numbers are stored in column 1 starting from row 8 all the way till the end.The numbers need to be evaluated based on the following conditions:\n\n\nFind 2 greatest possible numbers in this grid whose difference is more than 25,000.",
    "question": "The user taps on grid cells, then clicks on save and numbers are stored in column 1 starting from row 8 all the way till the end.The numbers need to be evaluated based on the following conditions:\n\n\nFind 2 greatest possible numbers in this grid whose difference is more than 25,000.",
    "code": "function evaluate(params) {\n  const { tableData, global_context_variables } = params;\n\n  /* ── 1) get the starting coordinates ────────────────────────────── */\n  const [rowStr = \"0\", colStr = \"0\"] =\n    (global_context_variables?.answer_list_start ?? \"0:0\").split(\":\");\n  const r0 = Number(rowStr);\n  const c0 = Number(colStr);\n\n  /* ── 2) read exactly the two numbers below that cell ────────────── */\n  const nums = [];\n  for (let r = r0; r < (tableData.cells ?? []).length; r++) {\n    const cell = tableData.cells[r]?.[c0];\n    const txt =\n      cell?.text?.enabled && cell?.text?.value?.default\n        ? cell.text.value.default.trim()\n        : \"\";\n    if (txt === \"\") break;            // stop at first blank cell\n    nums.push(Number(txt));\n  }\n\n  /* ── 3) validation targets ─────────────────────────────────────── */\n  const ALLOWED = [82639, 72591, 53170];\n\n  /* ── 4) decide status ──────────────────────────────────────────── */\n  let status = \"correct\";\n\n  // 4-a) both numbers must be on the allowed list\n  if (nums.length !== 2 || nums.some((n) => !ALLOWED.includes(n))) {\n    status = \"not_greatest\";\n  } else {\n    // 4-b) their absolute difference must be ≥ 25 000\n    const diff = Math.abs(nums[0] - nums[1]);\n    if (diff < 25000) status = \"not_25k_diff\";\n  }\n\n  /* ── 5) return standard structure ──────────────────────────────── */\n  return {\n    is_correct: status === \"correct\",\n    cell_level_is_correct: [],\n    condition_level_is_correct: [status], // single status value\n  };\n}\n",
    "metadata": {
      "activity_type": null,
      "difficulty": null,
      "tags": [],
      "source": "text-to-function(evaluation).xlsx",
      "row_index": 3
    }
  },
  {
    "id": 3,
    "prompt": "The user taps on grid cells, then clicks on save and numbers are stored in column 1 starting from row 8 all the way till the end.The numbers need to be evaluated based on the following conditions:\n\n\n1. All numbers should be greater than 67,000.\n2. The difference between the largest and smallest numbers should be exactly 17,000.\n3. All numbers should have the same digit in the hundreds place.",
    "question": "The user taps on grid cells, then clicks on save and numbers are stored in column 1 starting from row 8 all the way till the end.The numbers need to be evaluated based on the following conditions:\n\n\n1. All numbers should be greater than 67,000.\n2. The difference between the largest and smallest numbers should be exactly 17,000.\n3. All numbers should have the same digit in the hundreds place.",
    "code": "function getConditionCorrect(\n  variables,\n  conditions,\n  currConditionIndex,\n  getValue,\n  global_context_variables\n) {\n  /* ── 1) pull the answer column values as strings ────────────────── */\n  const tableData = global_context_variables?.tableData ?? {};\n  const [rowStr = \"0\", colStr = \"0\"] =\n    (global_context_variables?.answer_list_start ?? \"0:0\").split(\":\");\n  const r0 = Number(rowStr);\n  const c0 = Number(colStr);\n\n  const numStrs = [];\n  for (let r = r0; r < (tableData.cells ?? []).length; r++) {\n    const cell = tableData.cells[r]?.[c0];\n    const txt =\n      cell?.text?.enabled && cell?.text?.value?.default\n        ? cell.text.value.default.trim()\n        : \"\";\n    if (txt === \"\") break;            // stop at first blank cell\n    numStrs.push(txt);\n  }\n\n  /* ── 2) coerce to Number *once*  ────────────────────────────────── */\n  const nums = numStrs.map(Number);\n  if (nums.length === 0 || nums.some((n) => !Number.isFinite(n))) {\n    return false;                     // invalid / empty input → fail\n  }\n\n  /* ── 3) helper snippets ─────────────────────────────────────────── */\n  const greaterThan67000  = nums.every((n) => n > 67000);\n  const spreadIs17000     =\n    nums.length > 1 && Math.max(...nums) - Math.min(...nums) === 17000;\n  const sameHundredsDigit =\n    new Set(nums.map((n) => Math.floor(n / 100) % 10)).size === 1;\n\n  /* ── 4) dispatch on the requested rule ──────────────────────────── */\n  switch (currConditionIndex) {\n    case 0:  return greaterThan67000;\n    case 1:  return spreadIs17000;\n    case 2:  return sameHundredsDigit;\n    default: return false;            // unsupported index\n  }\n}\n\nfunction evaluate(params) {\n  const { tableData, global_context_variables } = params;\n\n  /* ── 1) locate the “answer list” column ─────────────────────────── */\n  const [rowStr = \"0\", colStr = \"0\"] =\n    (global_context_variables?.answer_list_start ?? \"0:0\").split(\":\");\n  const r0 = Number(rowStr);\n  const c0 = Number(colStr);\n\n  /* ── 2) gather every non-blank entry beneath that cell ──────────── */\n  const numStrs = [];\n  for (let r = r0; r < (tableData.cells ?? []).length; r++) {\n    const cell = tableData.cells[r]?.[c0];\n    const txt =\n      cell?.text?.enabled && cell?.text?.value?.default\n        ? cell.text.value.default.trim()\n        : \"\";\n    if (txt === \"\") break;                // first blank → stop\n    numStrs.push(txt);\n  }\n\n  /* ── 3) convert to Number once ──────────────────────────────────── */\n  const nums = numStrs.map(Number);\n  const numericOk = nums.length > 0 && nums.every(Number.isFinite);\n\n  /* ── 4) evaluate the three rules ────────────────────────────────── */\n  const cond0 = numericOk && nums.every((n) => n > 67000);\n\n  const cond1 =\n    numericOk &&\n    nums.length > 1 &&\n    Math.max(...nums) - Math.min(...nums) === 17000;\n\n  const cond2 =\n    numericOk &&\n    new Set(nums.map((n) => Math.floor(n / 100) % 10)).size === 1;\n\n  /* ── 5) return the standard structure ───────────────────────────── */\n  return {\n    is_correct: cond0 && cond1 && cond2,\n    cell_level_is_correct: [],                 // not required here\n    condition_level_is_correct: [cond0, cond1, cond2],\n  };\n}",
    "metadata": {
      "activity_type": null,
      "difficulty": null,
      "tags": [],
      "source": "text-to-function(evaluation).xlsx",
      "row_index": 4
    }
  },
  {
    "id": 4,
    "prompt": "The user taps on cell and the value for the cell gets doubled. The goal it to have the combined sum of all tapped cells be equal to target sum\n\nTap on a cell to double it and reach the target sum.",
    "question": "The user taps on cell and the value for the cell gets doubled. The goal it to have the combined sum of all tapped cells be equal to target sum\n\nTap on a cell to double it and reach the target sum.",
    "code": "function evaluate(params) {\n    const { tableData, helpers, global_context_variables } = params;\n    console.log(\"params-----------------------\", params);\n    let is_correct = false;\n    let cell_level_is_correct = [];\n    const fillColour = global_context_variables?.selected ?? '#0000FF';\n    const ansMap = JSON.parse(global_context_variables?.ans_map ?? \"{}\");\n    const currentRound = global_context_variables?.multiplayer_round\n    const ansTargetSum = Number(ansMap[`round_${currentRound}`]);\n\n\n    let targetsum = 0;\n    let count = 0;\n    tableData.cells.forEach((row, rowIndex) => {\n        row.forEach((cell, columnIndex) => {\n            if (cell.tappable?.enabled) {\n                const currentColor = cell.fillColor?.value;\n                if (currentColor == `${global_context_variables[`selected`]}`) {\n                    ++count;\n                    targetsum = targetsum + Number(cell?.text?.value?.default);\n                }\n            }\n        });\n    });\n\n    console.log('target_Summmmm', targetsum, ansTargetSum, currentRound, fillColour, ansMap);\n\n    tableData.cells.forEach((row, rowIndex) => {\n        cell_level_is_correct.push([]);\n        row.forEach((cell, columnIndex) => {\n            if (targetsum == ansTargetSum) {\n                cell_level_is_correct[rowIndex][columnIndex] = true;\n            } else {\n                cell_level_is_correct[rowIndex][columnIndex] = false;\n            }\n        });\n    });\n\n    if (targetsum == ansTargetSum) {\n        is_correct = true;\n    }\n    let sumCorrect = targetsum == ansTargetSum;\n    console.log('final', sumCorrect, is_correct, cell_level_is_correct, targetsum, ansTargetSum);\n    return {\n        is_correct,\n        cell_level_is_correct,\n        count,\n        sumCorrect\n    };\n}",
    "metadata": {
      "activity_type": null,
      "difficulty": null,
      "tags": [],
      "source": "text-to-function(evaluation).xlsx",
      "row_index": 5
    }
  },
  {
    "id": 5,
    "prompt": "Progressively tap cells in the steps described below.\n\nTap and select each block to create your path.\n\n1️⃣ Think of the smallest even number.\nMove that many steps down from the flag.\n\n2️⃣ Think of fingers on your hand,\nstep left by that many,\nand the treasure will be there.",
    "question": "Progressively tap cells in the steps described below.\n\nTap and select each block to create your path.\n\n1️⃣ Think of the smallest even number.\nMove that many steps down from the flag.\n\n2️⃣ Think of fingers on your hand,\nstep left by that many,\nand the treasure will be there.",
    "code": "function evaluate(params) {\n  const { tableData, helpers, global_context_variables } = params;\n  let is_correct = true;\n  let cell_level_is_correct = [];\n\n  const final_ending_cell = global_context_variables?.final_ending_cell;\n const final_cell_image = global_context_variables?.final_image;\n  let finalRow, finalColumn;\n if (final_ending_cell) {\n   const finalIds = final_ending_cell.split(\",\");\n   if (finalIds.length) {\n     for (let i = 0; i < finalIds.length; i++) {\n       const finalCellIds = finalIds[i].split(\":\");\n        finalRow = finalCellIds[0];\n        finalColumn = finalCellIds[1];\n     }\n   }\n }\n    console.log(\"final-cell\", finalRow, finalColumn)\n  tableData.cells.forEach((row, rowIndex) => {\n    cell_level_is_correct.push([]);\n    row.forEach((cell, columnIndex) => {\n          if (\n            tableData.cells[Number(finalRow)][Number(finalColumn)]\n              ?.imageBackground?.src?.default == final_cell_image\n          ) {\n            cell_level_is_correct[rowIndex][columnIndex] = true;\n          } else {\n            cell_level_is_correct[rowIndex][columnIndex] = false;\n            is_correct = false;\n          }\n        \n      \n    });\n  });\n  return {\n    is_correct,\n    cell_level_is_correct,\n  };\n}",
    "metadata": {
      "activity_type": null,
      "difficulty": null,
      "tags": [],
      "source": "text-to-function(evaluation).xlsx",
      "row_index": 6
    }
  },
  {
    "id": 6,
    "prompt": "Write the location of the map.\n\n1️⃣Count how many steps the map is on right from 0.\n2️⃣Use a comma. \n3️⃣Count how many steps it is above 0.\n\n\nWrite the location as steps right, steps up within brackets 👇🏽",
    "question": "Write the location of the map.\n\n1️⃣Count how many steps the map is on right from 0.\n2️⃣Use a comma. \n3️⃣Count how many steps it is above 0.\n\n\nWrite the location as steps right, steps up within brackets 👇🏽",
    "code": "function evaluate(params) {\n  const { tableData, helpers, global_context_variables } = params;\n  let is_correct = true;\n  let cell_level_is_correct = [];\n  let inRange = true;\n  let formatCorrect = true;\n\n  let coordinate = \"\";\n  let coordinateString = \"\";\n  tableData.cells.forEach((row, rowIndex) => {\n    row.forEach((cell, columnIndex) => {\n      if (cell?.input?.enabled) {\n        coordinateString = cell?.input?.value;\n        coordinate = cell?.input?.value.split(\",\").map((e) => Number(e));\n      }\n    });\n  });\n let xCoordinate = coordinate[0];\n let yCoordinate = coordinate[1];\n  function validateTwoNumbersWithComma(input) {\n    // Define the regex pattern: two numbers separated by a single comma\n    const regex = /^\\s*\\d+\\s*,\\s*\\d+\\s*$/;\n\n    // Test the input string against the regex\n    return regex.test(input);\n  }\n\n  if (!validateTwoNumbersWithComma(coordinateString)) {\n    formatCorrect = false;\n  }\n\n   if (\n     xCoordinate > Number(global_context_variables.max_x) ||\n     yCoordinate > Number(global_context_variables.max_y)\n   ) {\n     inRange = false;\n   }\n\n\n  tableData.cells.forEach((row, rowIndex) => {\n    cell_level_is_correct.push([]);\n    row.forEach((cell, columnIndex) => {\n      const { cellInputValue, cellIsInput, cellIsLatexBox } =\n        helpers.getCellInputValue(cell);\n      console.log(\n        \"evaluate---------\",\n        rowIndex,\n        columnIndex,\n        cellIsLatexBox,\n        cell\n      );\n      if (cellIsInput) {\n        const cellCorrectValueArr = helpers.getCellCorrectValues(cell);\n        const correctAns = cellCorrectValueArr[0]\n          .split(\",\")\n          .map((e) => Number(e));;\n       console.log(\"evaluation\", correctAns, coordinate);\n          if (\n            correctAns[0] == coordinate[0] &&\n            correctAns[1] == coordinate[1]\n          ) {\n            cell_level_is_correct[rowIndex][columnIndex] = true;\n          } else {\n            cell_level_is_correct[rowIndex][columnIndex] = false;\n            is_correct = false;\n          }\n        \n      }\n    });\n  });\n\n  console.log(\"final\", is_correct, inRange, formatCorrect)\n  return {\n    is_correct,\n    cell_level_is_correct,\n    inRange,\n    formatCorrect,\n  };\n}",
    "metadata": {
      "activity_type": null,
      "difficulty": null,
      "tags": [],
      "source": "text-to-function(evaluation).xlsx",
      "row_index": 7
    }
  },
  {
    "id": 7,
    "prompt": "Tap on grid cells to move the character and eventually reach the target cell.\n\n\nHelp the astronaut reach the spaceship!\n\nTap and select 1 block at a time to make the astronaut move.",
    "question": "Tap on grid cells to move the character and eventually reach the target cell.\n\n\nHelp the astronaut reach the spaceship!\n\nTap and select 1 block at a time to make the astronaut move.",
    "code": "function evaluate(params) {\n  const { tableData, global_context_variables } = params;\n  let is_correct = false;\n  const cell_level_is_correct = Array.from({ length: tableData.cells.length }, () => \n    Array(tableData.cells[0].length).fill(false)\n  );  // Initialize the matrix with `false`\n\n  // Check if cell 83 has final_image or cell 7,3 has selected_image\n  const finalImage = global_context_variables.final_image ?? '';\n  const selectedImage = global_context_variables.bunny ?? '';\n  let ending_cell = global_context_variables?.ending_cell ?? [];\n  let final_ending_cell = global_context_variables?.final_ending_cell ?? [];\n  if(ending_cell){\n    ending_cell = ending_cell.split(',');\n    ending_cell = ending_cell.map(c => c.split(':'));\n  }\n  if(final_ending_cell){\n    final_ending_cell = final_ending_cell.split(',');\n    final_ending_cell = final_ending_cell.map(c => c.split(':'));\n  }\n\n\n  // Check cell 83 (cell at row 8, column 3 - 0-indexed)\n  for(let i = 0; i < final_ending_cell?.length; i++){\n    const cell83 = tableData.cells[final_ending_cell[i][0]]?.[final_ending_cell[i][1]];  // cell 83 is at row 8, column 3 (0-indexed)\n    if (cell83 && cell83.imageBackground?.src?.default == finalImage) {\n      is_correct = true;\n    }\n  }\n\n  for(let i = 0; i < ending_cell?.length; i++){\n    const cell83 = tableData.cells[ending_cell[i][0]]?.[ending_cell[i][1]];  // cell 83 is at row 8, column 3 (0-indexed)\n    if (cell83 && cell83.imageBackground?.src?.default == selectedImage) {\n      is_correct = true;\n    }\n  }\n\n  // If either condition is met, mark the entire table as correct\n  if (is_correct) {\n    tableData.cells.forEach((row, rowIndex) => {\n      row.forEach((cell, columnIndex) => {\n        cell_level_is_correct[rowIndex][columnIndex] = true;\n      });\n    });\n  }\n\n  return {\n    is_correct,\n    cell_level_is_correct\n  };\n}",
    "metadata": {
      "activity_type": null,
      "difficulty": null,
      "tags": [],
      "source": "text-to-function(evaluation).xlsx",
      "row_index": 8
    }
  },
  {
    "id": 8,
    "prompt": "Tap on grid cells to move the character and eventually reach the target cell.\n\nAdded constraint is that all the cells in the path should sum to 400 points.\n\nFind a way to the star and add up the points given on the blocks, as you tap. \n\nCollect exactly 400 points on the way.",
    "question": "Tap on grid cells to move the character and eventually reach the target cell.\n\nAdded constraint is that all the cells in the path should sum to 400 points.\n\nFind a way to the star and add up the points given on the blocks, as you tap. \n\nCollect exactly 400 points on the way.",
    "code": "function evaluate(params) {\n  const { tableData, helpers, global_context_variables } = params;\n  let is_correct = false;\n  let cell_level_is_correct = [];\n  const ActiveColor = global_context_variables?.colour ?? '#FAF2C5';\n  const points = global_context_variables?.points ?? \"0-0\"; // Default range if points is not provided\n  let total = 0;\n  let endingCell = global_context_variables?.ending_cell ?? '';\n  if (endingCell) {\n    endingCell = endingCell.split(',');\n    endingCell = endingCell.map(c => c.split(':'));\n  }\n\n  // Parse the points range\n  const [minPoints, maxPoints] = points.split('-').map(Number);\n  tableData.cells.map(col => {\n    col.map(cell => {\n      if (cell.fillColor.default === ActiveColor) {\n        total += Number(cell.text.value.default);\n      }\n    });\n  });\n\nconsole.log(endingCell,'endingCell')\n  let isEndingCell = false;\n  for (let i = 0; i < endingCell.length; i++) {\n    console.log(endingCell[i][0],endingCell[i][1])\n    if (tableData.cells[endingCell[i][0]][endingCell[i][1]]?.tappable?.tap_count.default == \"1\") {\n      isEndingCell = true;\n      break;\n    }\n  }\n  if (total >= minPoints && total <= maxPoints && isEndingCell) {\n    is_correct = true;\n  }\n\n  tableData.cells.forEach((row, rowIndex) => {\n    cell_level_is_correct.push([]);\n    row.forEach((cell, columnIndex) => {\n      const { cellIsClick, cellClickValue } = helpers.getCellInputValue(cell);\n      const cellCorrectValueArr = helpers.getCellCorrectValues(cell);\n\n      if (cellIsClick) {\n        if (is_correct) {\n          cell_level_is_correct[rowIndex][columnIndex] = true;\n        } else {\n          cell_level_is_correct[rowIndex][columnIndex] = false;\n        }\n      }\n    });\n  });\n\n  return {\n    is_correct,\n    cell_level_is_correct,\n    total\n  };\n}",
    "metadata": {
      "activity_type": null,
      "difficulty": null,
      "tags": [],
      "source": "text-to-function(evaluation).xlsx",
      "row_index": 9
    }
  },
  {
    "id": 9,
    "prompt": "Tap on grid cells to move the character and eventually reach the target cell.\n\n\nThe blue bunny is at the start block. \n\nIt can jump 3 blocks at a time, which means it should skip two blocks every time it jumps.\n\nCan you make this bunny 👇🏽 reach the burrow?",
    "question": "Tap on grid cells to move the character and eventually reach the target cell.\n\n\nThe blue bunny is at the start block. \n\nIt can jump 3 blocks at a time, which means it should skip two blocks every time it jumps.\n\nCan you make this bunny 👇🏽 reach the burrow?",
    "code": "function getConditionCorrect(\n  variables,\n  conditions,\n  currConditionIndex,\n  getValue,\n  global_context_variables\n) {\n  const { tableData } = global_context_variables;\n\n const num = [];\n tableData?.cells.forEach((row, rowIndex) => {\n   row.forEach((cell, columnIndex) => {\n     if (cell?.fillColor?.default !== \"#000000\" && cell?.clickable?.enabled) {\n       // Initialize the column in the result array if not already present\n       if (!num[columnIndex]) {\n         num[columnIndex] = \"\";\n       }\n       // Concatenate the value of the cell to the column\n       num[columnIndex] += cell?.text?.value?.default;\n     }\n   });\n });\n  const numInFormat = num.map((e) => Number(e));\n  console.log(\"logger\", num, numInFormat);\n  function containsAllNumberTypes(numbers) {\n    // Flags to check for each type of number\n    let hasTwoDigit = false;\n    let hasThreeDigit = false;\n    let hasFourDigit = false;\n\n    // Iterate through the array\n    for (const number of numbers) {\n      const length = number?.length;\n\n      if (length === 2) {\n        hasTwoDigit = true;\n      } else if (length === 3) {\n        hasThreeDigit = true;\n      } else if (length === 4) {\n        hasFourDigit = true;\n      }\n\n      // If all types are found, no need to continue\n      if (hasTwoDigit && hasThreeDigit && hasFourDigit) {\n        return true;\n      }\n    }\n\n    // Return true only if all types are present\n    return hasTwoDigit && hasThreeDigit && hasFourDigit;\n  }\n\n  function hasSameTensPlace(numbers) {\n    if (numbers?.length === 0) return false; // Handle empty array\n\n    // Check if there is any number less than 10 (single-digit number or zero)\n    for (const number of numbers) {\n      if (number < 10) {\n        return false; // Return false if any number is less than 10 (single digit or 0)\n      }\n    }\n\n    // Extract the tens place of the first number\n    const firstTensDigit = Math.floor(numbers[0] / 10) % 10;\n\n    // Check if all other numbers have the same tens place digit\n    for (const number of numbers) {\n      const tensDigit = Math.floor(number / 10) % 10;\n      if (tensDigit !== firstTensDigit) {\n        return false; // Return false if tens digit doesn't match\n      }\n    }\n\n    return true; // All numbers have the same tens digit\n  }\n function hasOddOnesPlace(numbers) {\n   // Iterate through the array\n     if (numbers?.length == 0) {\n       return false;\n     }\n   for (const number of numbers) {\n     if (number === 0) {\n       return false; // Return false if the number is zero\n     }\n\n     const onesDigit = number % 10; // Extract the ones place digit\n     if (onesDigit % 2 === 0) {\n       return false; // Return false if any ones place digit is even\n     }\n   }\n   return true; // Return true if all ones place digits are odd and no zeros\n }\n\n  if (currConditionIndex == 0) {\n    return containsAllNumberTypes(num);\n  }\n\n  if (currConditionIndex == 1) {\n    return hasSameTensPlace(numInFormat);\n  }\n\n  if (currConditionIndex == 2) {\n    return hasOddOnesPlace(numInFormat);\n  }\n\n  return false;\n}\n\n\n\nfunction evaluate(params) {\n  const { tableData, helpers, global_context_variables } = params;\n  let is_correct = false;\n  let cell_level_is_correct = [];\n  const startingCell = global_context_variables.starting_cell;\n  const endingCell = global_context_variables.ending_cell;\n  const bunny = global_context_variables?.bunny ?? '';\n  const final_image = global_context_variables?.final_image ?? '';\n  const circle = global_context_variables?.circle ?? '';\n  const startingCellsIds = startingCell.split(',');\n  const endingCellsIds = endingCell.split(',');\n  let startingUpdated = false;\n  let endingUpdated = false;\n  if (startingCellsIds.length) {\n    for (let i = 0; i < startingCellsIds.length; i++) {\n      const startingCellIds = startingCellsIds[i].split(':');\n      const startingRow = startingCellIds[0];\n      const startingColumn = startingCellIds[1];\n      const startingCellData = tableData.cells[Number(startingRow)][Number(startingColumn)];\n      const startingCellTappable = startingCellData.imageBackground?.src;\n      console.log(startingCellTappable, 'startingCellTappable');\n      if (startingCellTappable.default == circle) {\n        startingUpdated = true;\n        break;\n      }\n    }\n  }\n  if (endingCellsIds.length) {\n    for (let i = 0; i < endingCellsIds.length; i++) {\n      const endingCellIds = endingCellsIds[i].split(':');\n      const endingRow = endingCellIds[0];\n      const endingColumn = endingCellIds[1];\n      const endingCellData = tableData.cells[Number(endingRow)][Number(endingColumn)];\n      const endingCellTappable = endingCellData.imageBackground?.src;\n      console.log(endingCellTappable, 'endingCellTappable');\n      if (endingCellTappable.default == final_image) {\n        endingUpdated = true;\n        break;\n      }\n    }\n  }\n  if (startingUpdated && endingUpdated) {\n    is_correct = true;\n  }\n  tableData.cells.forEach((row, rowIndex) => {\n    cell_level_is_correct.push([]);\n    row.forEach((cell, columnIndex) => {\n      const { cellIsClick, cellClickValue } = helpers.getCellInputValue(cell);\n      const cellCorrectValueArr = helpers.getCellCorrectValues(cell);\n      console.log('evaluate---------', rowIndex, columnIndex, cell, cellIsClick, cellClickValue, cellCorrectValueArr);\n      if (cellIsClick) {\n        if (is_correct) {\n          cell_level_is_correct[rowIndex][columnIndex] = true;\n        } else {\n          cell_level_is_correct[rowIndex][columnIndex] = false;\n          is_correct = false;\n        }\n      }\n    });\n  });\n  return {\n    is_correct,\n    cell_level_is_correct\n  };\n}",
    "metadata": {
      "activity_type": null,
      "difficulty": null,
      "tags": [],
      "source": "text-to-function(evaluation).xlsx",
      "row_index": 10
    }
  },
  {
    "id": 10,
    "prompt": "Tap on a block to hide its digit. Tap again to unhide it. \n\nOnly the digits that match the conditions should remain unhidden.\n\nEach column hides a number. Satisfy these conditions to find them👇🏽\n\n\n\n1. Make a 2-digit, a 3-digit and a 4-digit number\n2. All numbers have the same digit in the tens place\n3. Digit in the ones place should always be an odd number\n\n\nThe learner taps on grid cells. Any tapped cell turns its fill colour away from black and counts as “selected.”",
    "question": "Tap on a block to hide its digit. Tap again to unhide it. \n\nOnly the digits that match the conditions should remain unhidden.\n\nEach column hides a number. Satisfy these conditions to find them👇🏽\n\n\n\n1. Make a 2-digit, a 3-digit and a 4-digit number\n2. All numbers have the same digit in the tens place\n3. Digit in the ones place should always be an odd number\n\n\nThe learner taps on grid cells. Any tapped cell turns its fill colour away from black and counts as “selected.”",
    "code": "                function getConditionCorrect(\n                    variables,\n                    conditions,\n                    currConditionIndex,\n                    getValue,\n                ) {\n                    return false;\n                }\n            \n\nfunction evaluate(params) {\n  const { tableData, helpers } = params;\n  let is_correct = true;\n  let cell_level_is_correct = [];\n\n  const num = [];\n  tableData?.cells.forEach((row, rowIndex) => {\n    row.forEach((cell, columnIndex) => {\n     if (cell?.fillColor?.default !== \"#000000\" && cell?.clickable?.enabled) {\n       // Initialize the column in the result array if not already present\n       if (!num[columnIndex]) {\n         num[columnIndex] = \"\";\n       }\n       // Concatenate the value of the cell to the column\n       num[columnIndex] += cell?.text?.value?.default;\n     }\n    });\n  });\n  const numInFormat = num.map((e) => Number(e));\n  function containsAllNumberTypes(numbers) {\n    // Flags to check for each type of number\n    let hasTwoDigit = false;\n    let hasThreeDigit = false;\n    let hasFourDigit = false;\n\n    // Iterate through the array\n    for (const number of numbers) {\n      const length = number?.length;\n\n      if (length === 2) {\n        hasTwoDigit = true;\n      } else if (length === 3) {\n        hasThreeDigit = true;\n      } else if (length === 4) {\n        hasFourDigit = true;\n      }\n\n      // If all types are found, no need to continue\n      if (hasTwoDigit && hasThreeDigit && hasFourDigit) {\n        return true;\n      }\n    }\n\n    // Return true only if all types are present\n    return hasTwoDigit && hasThreeDigit && hasFourDigit;\n  }\n\n  function hasSameTensPlace(numbers) {\n    if (numbers?.length === 0) return false; // Handle empty array\n\n    // Check if there is any number less than 10 (single-digit number or zero)\n    for (const number of numbers) {\n      if (number < 10) {\n        return false; // Return false if any number is less than 10 (single digit or 0)\n      }\n    }\n\n    // Extract the tens place of the first number\n    const firstTensDigit = Math.floor(numbers[0] / 10) % 10;\n\n    // Check if all other numbers have the same tens place digit\n    for (const number of numbers) {\n      const tensDigit = Math.floor(number / 10) % 10;\n      if (tensDigit !== firstTensDigit) {\n        return false; // Return false if tens digit doesn't match\n      }\n    }\n\n    return true; // All numbers have the same tens digit\n  }\n  function hasOddOnesPlace(numbers) {\n    // Iterate through the array\n     if (numbers?.length == 0) {\n       return false;\n     }\n    for (const number of numbers) {\n      if (number === 0) {\n        return false; // Return false if the number is zero\n      }\n\n      const onesDigit = number % 10; // Extract the ones place digit\n      if (onesDigit % 2 === 0) {\n        return false; // Return false if any ones place digit is even\n      }\n    }\n    return true; // Return true if all ones place digits are odd and no zeros\n  }\n\n  tableData.cells.forEach((row, rowIndex) => {\n    cell_level_is_correct.push([]);\n    row.forEach((cell, columnIndex) => {\n      if (\n        containsAllNumberTypes(num) &&\n        hasSameTensPlace(numInFormat) &&\n        hasOddOnesPlace(numInFormat)\n      ) {\n        cell_level_is_correct[rowIndex][columnIndex] = true;\n      } else {\n        cell_level_is_correct[rowIndex][columnIndex] = false;\n        is_correct = false;\n      }\n    });\n  });\n  const indi = [\n    containsAllNumberTypes(num),\n    hasSameTensPlace(numInFormat),\n    hasOddOnesPlace(numInFormat),\n  ];\n  console.log(\"test\", is_correct, cell_level_is_correct);\n  return {\n    is_correct,\n    cell_level_is_correct,\n    indi,\n  };\n}",
    "metadata": {
      "activity_type": null,
      "difficulty": null,
      "tags": [],
      "source": "text-to-function(evaluation).xlsx",
      "row_index": 11
    }
  },
  {
    "id": 11,
    "prompt": "On the grid cells tap to rotate the pipes, eventuall connected pipes create flow paths then \n\n\nConnect the pipes to make the water flow from the start to the tank. \n\nTap on the pipes to turn them!",
    "question": "On the grid cells tap to rotate the pipes, eventuall connected pipes create flow paths then \n\n\nConnect the pipes to make the water flow from the start to the tank. \n\nTap on the pipes to turn them!",
    "code": "function evaluate(params) {\n    const { tableData, helpers, global_context_variables } = params;\n\n    const ans = global_context_variables.ans;\n    const range = ans.split('-').map(item => Number(item));\n\n    let is_correct = true;\n    let cell_level_is_correct = [];\n    let cell_path_level_is_correct = [];\n    let cell_level_skip_evaluation = [];\n    let targetSum = 0;\n\n    const paths = tableData?.feedback?.paths;\n  console.log(\"paths\", paths);\n\n    // Check if paths are empty and set is_correct to false if so\n    if (!paths || paths.length === 0) {\n        is_correct = false;\n        for (let row = 0; row < tableData.cells.length; row++) {\n            cell_level_is_correct[row] = [];\n            cell_level_skip_evaluation[row] = [];\n            for (let cell = 0; cell < tableData.cells[row].length; cell++) {\n                cell_level_is_correct[row][cell] = false;\n                cell_level_skip_evaluation[row][cell] = false;\n            }\n        }\n        console.log(\"evaluationFunction------------\", {\n            is_correct,\n            targetSum,\n            cell_level_is_correct,\n            cell_path_level_is_correct,\n            cell_level_skip_evaluation\n        });\n        return {\n            is_correct,\n            targetSum,\n            cell_level_is_correct,\n            cell_path_level_is_correct,\n            cell_level_skip_evaluation\n        };\n    }\n\n    // Initialize cell_level_is_correct and cell_path_level_is_correct\n    for (let row = 0; row < tableData.cells.length; row++) {\n        if (!cell_level_is_correct[row]) {\n            cell_level_is_correct[row] = [];\n            cell_level_skip_evaluation[row] = [];\n        }\n        cell_path_level_is_correct[row] = [];\n        for (let cell = 0; cell < tableData.cells[row].length; cell++) {\n            cell_level_is_correct[row][cell] = true;\n            cell_path_level_is_correct[row][cell] = {};\n            cell_level_skip_evaluation[row][cell] = true;\n        }\n    }\n\n    let pathSumsObj = {};\n    paths.forEach((path, pathIndex) => {\n        const key = String(pathIndex);\n        let pathSum = 0;\n        path.cells.forEach(([rowIndex, cellIndex]) => {\n            const cellObj = tableData.cells[rowIndex][cellIndex];\n            if (cellObj?.text?.value?.default) {\n                pathSum += Number(cellObj?.text?.value?.default);\n            }\n            cell_level_is_correct[rowIndex][cellIndex] = true;\n            cell_level_skip_evaluation[rowIndex][cellIndex] = false;\n            cell_path_level_is_correct[rowIndex][cellIndex][key] = true;\n        });\n        pathSumsObj[key] = pathSum;\n        targetSum += pathSum; // Accumulate the total sum\n    });\n\n    paths.forEach((path, pathIndex) => {\n        const last = path.cells[path.cells.length - 1];\n        const [lastRowIndex, lastCellIndex] = last;\n        const lastCellObj = tableData.cells[lastRowIndex][lastCellIndex];\n        const isLastCellEnd = lastCellObj?.rotationFlow?.settings?.isEnd;\n        const pathSum = pathSumsObj[String(pathIndex)];\n\n        console.log(\"isLastCellEnd\", isLastCellEnd, pathSum, path)\n\n        if (!(pathSum > range[0] && pathSum < range[1]) || !isLastCellEnd) {\n            cell_level_is_correct[lastRowIndex][lastCellIndex] = false;\n            cell_path_level_is_correct[lastRowIndex][lastCellIndex][String(pathIndex)] = false;\n            is_correct = false;\n        }\n    });\n\n    if (!is_correct) {\n        for (let row = 0; row < tableData.cells.length; row++) {\n            for (let cell = 0; cell < tableData.cells[row].length; cell++) {\n                cell_level_is_correct[row][cell] = false;\n            }\n        }\n    }\n\n    console.log(\"evaluationFunction------------\", {\n        is_correct,\n        targetSum,\n        cell_level_is_correct,\n        cell_path_level_is_correct,\n        cell_level_skip_evaluation\n    });\n\n    return {\n        is_correct,\n        targetSum,\n        cell_level_is_correct,\n        cell_path_level_is_correct,\n        cell_level_skip_evaluation\n    };\n}",
    "metadata": {
      "activity_type": null,
      "difficulty": null,
      "tags": [],
      "source": "text-to-function(evaluation).xlsx",
      "row_index": 12
    }
  },
  {
    "id": 12,
    "prompt": "On the grid cells tap to rotate the pipes, eventuall connected pipes create flow paths then the sum of paths should be the target number\n\n\nMake water flow from the start to the tank. Tap on the pipes to turn them!\n\nAdd the numbers on the pipes.\n\nYour total should be 315 👇🏽",
    "question": "On the grid cells tap to rotate the pipes, eventuall connected pipes create flow paths then the sum of paths should be the target number\n\n\nMake water flow from the start to the tank. Tap on the pipes to turn them!\n\nAdd the numbers on the pipes.\n\nYour total should be 315 👇🏽",
    "code": "function evaluate(params) {\n    const { tableData, helpers, global_context_variables } = params;\n\n    const ans = global_context_variables.ans;\n    const range = Number(ans);\n\n    let is_correct = true;\n    let cell_level_is_correct = [];\n    let cell_path_level_is_correct = [];\n    let cell_level_skip_evaluation = [];\n    let targetSum = 0;\n\n    const wetPipes = tableData?.feedback?.wetPipes;\n\n    // Initialize cell_level_is_correct and cell_level_skip_evaluation\n    for (let row = 0; row < tableData.cells.length; row++) {\n        cell_level_is_correct[row] = [];\n        cell_level_skip_evaluation[row] = [];\n        cell_path_level_is_correct[row] = [];\n        for (let cell = 0; cell < tableData.cells[row].length; cell++) {\n            cell_level_is_correct[row][cell] = false;\n            cell_level_skip_evaluation[row][cell] = true;\n            cell_path_level_is_correct[row][cell] = {};\n        }\n    }\n\n    // Calculate sum of wetPipes\n    if (wetPipes && wetPipes.length > 0) {\n        let wetPipesSum = 0;\n        wetPipes.forEach(([rowIndex, cellIndex]) => {\n            const cellObj = tableData.cells[rowIndex][cellIndex];\n            if (cellObj?.text?.value?.default) {\n                wetPipesSum += Number(cellObj?.text?.value?.default);\n            }\n            cell_level_skip_evaluation[rowIndex][cellIndex] = false;\n        });\n\n        // Check if wetPipes sum equals the target range\n        const isLastCellNotEnd = tableData?.feedback?.paths?.find((path)=>{\n        const lastPath = path?.cells[path?.cells?.length-1]\n        return !tableData.cells[lastPath[0]][lastPath[1]]?.rotationFlow?.settings?.isEnd\n      });\n        is_correct = wetPipesSum === range && !isLastCellNotEnd;\n\n\n        // Mark all cells based on the sum comparison\n        for (let row = 0; row < tableData.cells.length; row++) {\n            for (let cell = 0; cell < tableData.cells[row].length; cell++) {\n                cell_level_is_correct[row][cell] = is_correct;\n            }\n        }\n\n        targetSum = wetPipesSum;\n    } else {\n        is_correct = false;\n    }\n\n    console.log(\"evaluationFunction------------\", {\n        is_correct,\n        targetSum,\n        cell_level_is_correct,\n        cell_path_level_is_correct,\n        cell_level_skip_evaluation,\n    });\n\n    return {\n        is_correct,\n        targetSum,\n        cell_level_is_correct,\n        cell_path_level_is_correct,\n        cell_level_skip_evaluation,\n    };\n}",
    "metadata": {
      "activity_type": null,
      "difficulty": null,
      "tags": [],
      "source": "text-to-function(evaluation).xlsx",
      "row_index": 13
    }
  },
  {
    "id": 13,
    "prompt": "drag and drop matchsticks to satisfy the question condition.\n\nMake the greatest number possible by moving only @@maxMoves@@ matchsticks",
    "question": "drag and drop matchsticks to satisfy the question condition.\n\nMake the greatest number possible by moving only @@maxMoves@@ matchsticks",
    "code": "function evaluate(params) {\n  const { tableData, helpers, global_context_variables = {} } = params;\n\n  /* ── 0. Extract auxiliary counters (pass straight through) ───── */\n  const attemptNumber = Number(global_context_variables.attemptNumber ?? 1);\n  const maxAttempts   = Number(global_context_variables.maxAttempts   ?? 2);\n  const movesLeft     = Number(global_context_variables.movesLeft     ?? 1);\n\n  /* ── 1. Prep answer & mapping ─────────────────────────────────── */\n  const paths   = tableData?.feedback?.paths ?? [];\n  const mapping = JSON.parse(global_context_variables.numbers ?? \"{}\");\n  const answer  = String(global_context_variables.ans ?? \"\")\n                    .split(\"\")\n                    .map(Number);        /* \"95\" → [9,5] */\n\n  /* ── 2. Allocate result matrices ─────────────────────────────── */\n  const rows = tableData.cells.length;\n  const cols = Math.max(...tableData.cells.map(r => r.length));\n\n  const cell_level_is_correct      = Array.from({ length: rows }, () => Array(cols).fill(false));\n  const cell_path_level_is_correct = Array.from({ length: rows }, () => Array(cols).fill({}));\n\n  /* ── 3. Helpers ──────────────────────────────────────────────── */\n  const arraysEqual = (a, b) => a.length === b.length && a.every((v, i) => v === b[i]);\n\n  const digitForPattern = (pattern) => {\n    for (const key in mapping) {\n      for (const sub of mapping[key]) {\n        if (arraysEqual(sub, pattern)) return Number(key);\n      }\n    }\n    return undefined;                             // no match\n  };\n\n  /* ── 4. Evaluate each path ───────────────────────────────────── */\n  const pathDigits     = [];      // like [9, 5]\n  const pathIsCorrect  = [];\n  let   isNumberWrong  = false;\n\n  paths.forEach((path, idx) => {\n    /* Build 0/1 pattern for this path */\n    const pattern = path.cells.map(([r, c]) => {\n      const cell = tableData.cells[r][c];\n      if (!cell.dragDrop?.enabled) return 1;          // fixed stick\n      const { cellInputValue } = helpers.getCellInputValue(cell);\n      return cellInputValue === \"1\" ? 1 : 0;\n    });\n\n    const digit = digitForPattern(pattern);\n    pathDigits.push(digit);\n\n    if (digit === undefined) {\n      isNumberWrong = true;\n      pathIsCorrect[idx] = false;\n    } else {\n      const expected = answer[idx];   // could be undefined if answer shorter\n      pathIsCorrect[idx] = digit === expected;\n    }\n  });\n\n  /* Extra digits in target answer that have no path → incorrect */\n  for (let i = paths.length; i < answer.length; i++) pathIsCorrect[i] = false;\n\n  const is_correct = pathIsCorrect.every(Boolean);\n\n  /* ── 5. Populate per-cell correctness matrices ───────────────── */\n  paths.forEach((path, pathIdx) => {\n    const correct = pathIsCorrect[pathIdx] ?? false;\n    const key     = String(pathIdx);\n\n    path.cells.forEach(([r, c]) => {\n      cell_level_is_correct[r][c] = is_correct;\n      cell_path_level_is_correct[r][c] = {\n        ...cell_path_level_is_correct[r][c],\n        [key]: correct,\n      };\n    });\n  });\n\n  /* ── 6. Build the integer the learner formed, if any ─────────── */\n  const madeNum = pathDigits.every(d => typeof d === \"number\")\n                  ? Number(pathDigits.join(\"\"))\n                  : null;     // invalid / incomplete number\n\n  /* ── 7. Ship EVERYTHING needed by feedback layer ─────────────── */\n  return {\n    /* verdicts  */\n    is_correct,\n    isNumberWrong,\n    madeNum,\n\n    /* attempt / move bookkeeping  */\n    attemptNumber,\n    maxAttempts,\n    movesLeft,\n\n    /* still return matrices if UI needs them */\n    cell_level_is_correct,\n    cell_path_level_is_correct,\n  };\n}",
    "metadata": {
      "activity_type": null,
      "difficulty": null,
      "tags": [],
      "source": "text-to-function(evaluation).xlsx",
      "row_index": 14
    }
  },
  {
    "id": 14,
    "prompt": "Solve the nonograms! \n\nTap once to colour black, tap again to mark ✖️,  and tap again to reset.",
    "question": "Solve the nonograms! \n\nTap once to colour black, tap again to mark ✖️,  and tap again to reset.",
    "code": "function evaluate(params) {\n  const { tableData, global_context_variables } = params;\n\n  const img2 = Object.keys(global_context_variables)\n    .filter(key => key.startsWith(\"img2\"))\n    .map(key => global_context_variables[key])[0];\n  const img1 = Object.keys(global_context_variables)\n    .filter(key => key.startsWith(\"img1\"))\n    .map(key => global_context_variables[key])[0];\n\n\n  let is_correct = true;\n  const row_correctness = new Array(tableData.cells.length).fill(true);\n  const column_correctness = new Array(tableData.cells[0].length).fill(true);\n\n  // Initialize cell-level correctness matrix\n  const cell_level_is_correct = tableData.cells.map(row =>\n    row.map(() => true)\n  );\n\n  // Helper function to parse clues from a clue cell\n  function parseCluesFromCell(cell) {\n    const cellContent = cell?.text?.value?.default || \"\";\n    // console.log(Parsing clues from clue cell: \"${cellContent}\");\n\n    // Extract numeric groups separated by backslashes (\\)\n    const clues = cellContent.split(\"\\\\\").map(clue => parseInt(clue.trim(), 10)).filter(num => !isNaN(num));\n\n    // console.log(Extracted clues: ${clues});\n    return clues;\n  }\n\n  // Helper function to find the clue cell in a row or column\n  function findClueCell(cells) {\n    for (let i = 0; i < cells.length; i++) {\n      if (cells[i].imageBackground?.src?.default && cells[i].imageBackground?.src?.default !== img2 && cells[i].imageBackground?.src?.default !== img1) {\n        // console.log(Clue cell found at index ${i}:, cells[i]);\n        return cells[i];\n      }\n    }\n    // console.log(\"No clue cell found.\");\n    return null;\n  }\n\n  // Helper function to validate groups of colored cells\n  function validateGroups(cells, clues, startIndex) {\n    const groups = [];\n    let currentGroupSize = 0;\n\n    // console.log(Validating groups with clues: ${clues}, starting from index: ${startIndex});\n\n    for (let i = startIndex; i < cells.length; i++) {\n      const isColored = cells[i].imageBackground?.src?.default === img2;\n\n      // console.log(Cell ${i} - Colored: ${isColored});\n\n      if (isColored) {\n        currentGroupSize++;\n      } else if (currentGroupSize > 0) {\n        groups.push(currentGroupSize);\n        currentGroupSize = 0;\n      }\n    }\n\n    if (currentGroupSize > 0) {\n      groups.push(currentGroupSize);\n    }\n\n    // console.log(Groups found: ${groups});\n    const isValid = JSON.stringify(clues) === JSON.stringify(groups);\n    // console.log(Validation result: ${isValid});\n    return isValid;\n  }\n\n  // Analyze Rows\n  for (let rowIndex = 1; rowIndex < tableData.cells.length; rowIndex++) { // Start from row 1\n    const row = tableData.cells[rowIndex];\n    // console.log(\\nAnalyzing Row ${rowIndex}:);\n    const clueCell = findClueCell(row);\n    const clues = clueCell ? parseCluesFromCell(clueCell) : [];\n    const gridStart = row.indexOf(clueCell) + 1;\n\n    // console.log(Row ${rowIndex} clues: ${clues});\n    const isRowValid = validateGroups(row, clues, gridStart);\n\n    if (!isRowValid) {\n      // console.log(Row ${rowIndex} validation failed.);\n      row_correctness[rowIndex] = false;\n      is_correct = false;\n    } else {\n      // console.log(Row ${rowIndex} validation passed.);\n    }\n  }\n\n  // Analyze Columns\n  for (let colIndex = 1; colIndex < tableData.cells[0].length; colIndex++) { // Start from column 1\n    const column = tableData.cells.map(row => row[colIndex]);\n    // console.log(\\nAnalyzing Column ${colIndex}:);\n    const clueCell = findClueCell(column);\n    const clues = clueCell ? parseCluesFromCell(clueCell) : [];\n    const gridStart = column.indexOf(clueCell) + 1;\n\n    // console.log(Column ${colIndex} clues: ${clues});\n    const isColumnValid = validateGroups(column, clues, gridStart);\n\n    if (!isColumnValid) {\n      // console.log(Column ${colIndex} validation failed.);\n      column_correctness[colIndex] = false;\n      is_correct = false;\n    } else {\n      // console.log(Column ${colIndex} validation passed.);\n    }\n  }\n\n  // Automatically set first row and column to true\n  row_correctness[0] = true;\n  column_correctness[0] = true;\n\n  // Calculate cell-level correctness\n  for (let rowIndex = 0; rowIndex < tableData.cells.length; rowIndex++) {\n    for (let colIndex = 0; colIndex < tableData.cells[rowIndex].length; colIndex++) {\n      cell_level_is_correct[rowIndex][colIndex] =\n        row_correctness[rowIndex] && column_correctness[colIndex];\n\n      // console.log(\n      //   Cell [${rowIndex}, ${colIndex}] - Row Correct: ${row_correctness[rowIndex]}, Column Correct: ${column_correctness[colIndex]}, Final Correct: ${cell_level_is_correct[rowIndex][colIndex]}\n      // );\n    }\n  }\n\n  // console.log(\"\\nFinal Evaluation Results:\", {\n  //   is_correct,\n  //   row_correctness,\n  //   column_correctness,\n  //   cell_level_is_correct,\n  // });\n\n  return {\n    is_correct,\n    row_correctness,\n    column_correctness,\n    cell_level_is_correct,\n  };\n}",
    "metadata": {
      "activity_type": null,
      "difficulty": null,
      "tags": [],
      "source": "text-to-function(evaluation).xlsx",
      "row_index": 15
    }
  },
  {
    "id": 15,
    "prompt": "Solve this Kakuro!\n\nYou can use each digit more than once in this Kakuro. \n\n\nHowever, digits cannot be repeated within the same row or column.",
    "question": "Solve this Kakuro!\n\nYou can use each digit more than once in this Kakuro. \n\n\nHowever, digits cannot be repeated within the same row or column.",
    "code": "function evaluate(params) {\n  const { tableData, helpers } = params;\n  let is_correct = true;\n  function getGridVariables(tableData) {\n    function getStringToNumberMap(tableCells) {\n      const result = [];\n      for (let row = 0; row < tableCells.length; row++) {\n        for (let col = 0; col < tableCells[row].length; col++) {\n          const cell = tableCells[row][col];\n          if (typeof cell === 'string' && ['👇🏽', '👉🏽'].some(i => cell.includes(i))) {\n            let numberKey = cell;\n            if (cell.includes('👇🏽')) {\n              let rowBelow = row + 1;\n              let numberString = '';\n              let startRow = null;\n              while (rowBelow < tableCells.length && tableCells[rowBelow][col] !== '') {\n                if (!startRow) startRow = rowBelow;\n                numberString += tableCells[rowBelow][col];\n                rowBelow++;\n              }\n              if (numberString) {\n                result.push({\n                  label: numberKey,\n                  value: [\n                    [startRow, col],\n                    [rowBelow - 1, col]\n                  ]\n                });\n              }\n            } else if (cell.includes('👉🏽')) {\n              let colRight = col + 1;\n              let numberString = '';\n              let startCol = null;\n              while (colRight < tableCells[row].length && tableCells[row][colRight] !== '') {\n                if (!startCol) startCol = colRight;\n                numberString += tableCells[row][colRight];\n                colRight++;\n              }\n              if (numberString) {\n                result.push({\n                  label: numberKey,\n                  value: [\n                    [row, startCol],\n                    [row, colRight - 1]\n                  ]\n                });\n              }\n            }\n          }\n        }\n      }\n      return result;\n    }\n    const nums = getStringToNumberMap((tableData ?? []).map(i => i.map(j => j.value ?? j.text?.value?.default ?? '')));\n    return nums;\n  }\n  const gridVariables = getGridVariables(tableData.cells);\n  const formAttempt = [];\n  const correct = [];\n  tableData.cells.forEach((row, rowIndex) => {\n    row.forEach((cell, columnIndex) => {\n      const { cellInputValue, cellIsInput, cellIsLatexBox } = helpers.getCellInputValue(cell);\n      const cellCorrectValueArr = helpers.getCellCorrectValues(cell);\n      if (!formAttempt[rowIndex]) formAttempt[rowIndex] = [];\n      formAttempt[rowIndex][columnIndex] = cellInputValue;\n      cellCorrectValueArr?.forEach((i, idx) => {\n        if (!correct[idx]) correct[idx] = [];\n        if (!correct[idx][rowIndex]) correct[idx][rowIndex] = [];\n        correct[idx][rowIndex][columnIndex] = i;\n      });\n    });\n  });\n\n  function levenshteinDistance(s1, s2) {\n    if (s1.length > s2.length) {\n      [s1, s2] = [s2, s1];\n    }\n\n    let distances = Array.from({ length: s1.length + 1 }, (_, i) => i);\n    for (let i = 0; i < s2.length; i++) {\n      let newDistances = [i + 1];\n      for (let j = 0; j < s1.length; j++) {\n        if (s1[j] === s2[i]) {\n          newDistances.push(distances[j]);\n        } else {\n          newDistances.push(1 + Math.min(distances[j], distances[j + 1], newDistances[newDistances.length - 1]));\n        }\n      }\n      distances = newDistances;\n    }\n\n    return distances[s1.length];\n  }\n\n  function findMostMatchingString(referenceString, stringList) {\n    let bestMatch = null;\n    let minDistance = Infinity;\n\n    for (let i = 0; i < stringList.length; i++) {\n      let string = stringList[i];\n      let distance = levenshteinDistance(referenceString, string);\n      if (distance < minDistance) {\n        minDistance = distance;\n        bestMatch = string;\n      }\n    }\n\n    return bestMatch;\n  }\n\n  function extractValueFromFormAttempt(formAttemptGrid, gridVariables) {\n    const checkObject = {};\n\n    gridVariables.forEach(gridVariable => {\n      const gridVariableLabel = gridVariable.label;\n      checkObject[gridVariableLabel] = '';\n\n      const startingPoint = gridVariable.value[0];\n      const endPoint = gridVariable.value[1];\n      const isRowSame = startingPoint[0] === endPoint[0];\n      const isColSame = startingPoint[1] === endPoint[1];\n\n      if (isRowSame) {\n        for (let i = startingPoint[1]; i <= endPoint[1]; i++) {\n          const value = formAttemptGrid[startingPoint[0]][i];\n          checkObject[gridVariableLabel] += value;\n        }\n      } else if (isColSame) {\n        for (let i = startingPoint[0]; i <= endPoint[0]; i++) {\n          const value = formAttemptGrid[i][startingPoint[1]];\n          checkObject[gridVariableLabel] += value;\n        }\n      }\n    });\n\n    return checkObject;\n  }\n\n  function getTheMostMatchingObjFromFormAttempt(formAttempt, correct, gridVariables, correctSize) {\n    const newFormAttemptGrid = formAttempt;\n\n    if (newFormAttemptGrid) {\n      const correctAnsArr = correct;\n\n      const correctAnsAsObj = correctAnsArr.map(form => extractValueFromFormAttempt(form, gridVariables));\n\n      const userAttempt = extractValueFromFormAttempt(newFormAttemptGrid, gridVariables);\n\n      const maxMatchArr = correctAnsAsObj.map(ans => Object.keys(ans).filter(key => ans[key] === userAttempt[key]).length);\n\n      const maxMatchCounts = Math.max(...maxMatchArr);\n      const maxMatchArrWithMaxCount = maxMatchArr\n        .map((count, idx) => (count === maxMatchCounts ? correctAnsAsObj[idx] : false))\n        .filter(obj => obj);\n\n      const getFlattened = obj => Object.values(obj).join('');\n      const maxMatchArrWithMaxCountString = maxMatchArrWithMaxCount.map(getFlattened);\n\n      const mostMatchingString = findMostMatchingString(getFlattened(userAttempt), maxMatchArrWithMaxCountString);\n\n      const correctMatch = maxMatchArrWithMaxCount[maxMatchArrWithMaxCountString.indexOf(mostMatchingString)];\n      const obj = {};\n      obj.value = {};\n      obj.status = {};\n      obj.correct = correct[correctAnsAsObj.map(i => Object.values(i).join('')).indexOf(mostMatchingString)];\n      Object.keys(correctMatch).forEach(key => {\n        obj['value'][key] = correctMatch[key];\n        obj['status'][key] = correctMatch[key] === userAttempt[key];\n      });\n      return obj;\n    }\n  }\n\n  const arr = getTheMostMatchingObjFromFormAttempt(formAttempt, correct, gridVariables, correct.length);\n  let cell_level_is_correct = formAttempt.map((i, ii) =>\n    i.map((j, ji) => {\n      if (!j) return;\n      return j == arr.correct[ii][ji];\n    })\n  );\n  return {\n    is_correct: !Object.values(arr.status).includes(false),\n    cell_level_is_correct\n  };\n}",
    "metadata": {
      "activity_type": null,
      "difficulty": null,
      "tags": [],
      "source": "text-to-function(evaluation).xlsx",
      "row_index": 16
    }
  }
]